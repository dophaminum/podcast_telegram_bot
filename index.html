<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Плеер</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            background-color: var(--tg-theme-bg-color, #222); 
            color: var(--tg-theme-text-color, #fff); 
            margin: 0; 
            padding: 15px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            height: 100vh; 
            box-sizing: border-box; 
        }
        #title { 
            font-size: 18px; 
            font-weight: bold; 
            margin-bottom: 20px; 
            text-align: center; 
        }
        audio { 
            width: 100%; 
            max-width: 400px; 
        }
        #time-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            color: var(--tg-theme-hint-color, #aaa);
            margin-top: 8px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

    <div id="title">Загрузка аудио...</div>
    <audio id="player" controls></audio>
    <div id="time-display">--:-- / --:--</div>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        const titleDiv = document.getElementById('title');
        const player = document.getElementById('player');
        const timeDisplay = document.getElementById('time-display');
        
        let fileId = null;
        let storageKey = null;
        let lastUpdateTime = 0; // Для отправки данных боту

        // Функция для отправки данных боту (вспомогательная)
        function sendProgressUpdate(isFinished = false) {
            if (!fileId) return;
            const currentTime = Math.floor(player.currentTime);
            const dataToSend = {
                file_id: fileId,
                position: currentTime,
                is_finished: isFinished,
            };
            tg.sendData(JSON.stringify(dataToSend));
        }

        // Функция для красивого отображения времени
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) {
                return "--:--";
            }
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        try {
            const urlParams = new URLSearchParams(window.location.search);
            fileId = urlParams.get('file_id');
            const fileUrl = urlParams.get('file_url');
            const fileName = urlParams.get('file_name') || 'Аудиозапись';
            const totalDuration = parseInt(urlParams.get('duration') || '0', 10);
            
            if (!fileUrl || !fileId) {
                throw new Error("ID или URL файла не указаны.");
            }
            
            // Основная логика с localStorage (главный источник правды)
            storageKey = `progress_${fileId}`; 
            const savedProgress = localStorage.getItem(storageKey);
            let lastPosition = savedProgress ? parseInt(savedProgress, 10) : 0;
            
            titleDiv.innerText = fileName;
            player.src = fileUrl;
            timeDisplay.innerText = `${formatTime(lastPosition)} / ${formatTime(totalDuration)}`;

            // ОБРАБОТЧИКИ СОБЫТИЙ
            player.addEventListener('canplaythrough', () => {
                // Всегда доверяем localStorage, а не данным от бота
                player.currentTime = lastPosition;
                player.play();
            }, { once: true });

            player.addEventListener('timeupdate', () => {
                const currentTime = Math.floor(player.currentTime);
                // 1. Обновляем время на экране
                timeDisplay.innerText = `${formatTime(currentTime)} / ${formatTime(totalDuration)}`;

                // 2. Надежно сохраняем в localStorage
                localStorage.setItem(storageKey, currentTime);

                // 3. Пытаемся отправить данные боту для отображения (не критично, если не дойдет)
                const now = Date.now();
                if (now - lastUpdateTime > 5000) {
                    sendProgressUpdate();
                    lastUpdateTime = now;
                }
            });

            player.addEventListener('ended', () => {
                localStorage.setItem(storageKey, '0'); // Сбрасываем для следующего прослушивания
                sendProgressUpdate(true); // Отправляем финальный статус
            });

            tg.onEvent('viewportChanged', (event) => {
                if (!event.isStateStable) {
                     sendProgressUpdate();
                }
            });
            
        } catch (e) {
            tg.showAlert(`Критическая ошибка: ${e.message}`);
        }
    </script>
</body>
</html>

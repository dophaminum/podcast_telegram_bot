<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Плеер</title>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: var(--tg-theme-bg-color, #222); color: var(--tg-theme-text-color, #fff); }
        .app-container { display: flex; flex-direction: column; height: 100%; }
        .main-content { flex-grow: 1; overflow-y: auto; padding: 15px; text-align: center; }
        .footer { flex-shrink: 0; padding: 0 15px 15px 15px; }
        #title { font-size: 18px; font-weight: bold; overflow-wrap: break-word; word-break: break-word; margin-bottom: 20px; }
        audio { width: 100%; max-width: 400px; margin: 0 auto; display: none; } /* Плеер изначально скрыт */
        #time-display { font-family: 'Courier New', Courier, monospace; font-size: 16px; color: var(--tg-theme-hint-color, #aaa); margin-top: 8px; }
        #loader { margin-top: 20px; font-size: 14px; color: var(--tg-theme-hint-color, #aaa); }
        #timecodes-container { width: 100%; max-width: 400px; margin: 20px auto 0 auto; display: flex; flex-direction: column; gap: 8px; }
        .timecode-button { width: 100%; padding: 12px 15px; border: none; border-radius: 8px; background-color: var(--tg-theme-secondary-bg-color, #333); color: var(--tg-theme-text-color, #fff); cursor: pointer; font-size: 14px; text-align: left; }
        #close-button { width: 100%; max-width: 400px; display: block; margin: 0 auto; padding: 12px; border: none; border-radius: 8px; background-color: var(--tg-theme-button-color, #007bff); color: var(--tg-theme-button-text-color, #fff); cursor: pointer; font-size: 16px; font-weight: bold; }
    </style>
</head>
<body>

    <div class="app-container">
        <div class="main-content">
            <div id="title">Загрузка информации...</div>
            <audio id="player" preload="metadata"></audio>
            <div id="time-display">--:-- / --:--</div>
            <div id="loader"></div>
            <div id="timecodes-container"></div>
        </div>
        <div class="footer">
            <button id="close-button">Закрыть</button>
        </div>
    </div>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        // --- Получаем HTML-элементы ---
        const titleDiv = document.getElementById('title');
        const player = document.getElementById('player');
        const timeDisplay = document.getElementById('time-display');
        const timecodesContainer = document.getElementById('timecodes-container');
        const closeButton = document.getElementById('close-button');
        const loaderDiv = document.getElementById('loader');
        
        // --- Переменные состояния ---
        let fileId = null;
        let userId = null;
        let storageKey = null;
        let baseApiUrl = '';
        let lastUpdateTime = 0;

        // --- Вспомогательные функции ---
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "--:--";
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function timeStrToSeconds(timeStr) {
            const parts = timeStr.split(':').map(Number);
            let seconds = 0;
            if (parts.length === 3) seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
            else if (parts.length === 2) seconds = parts[0] * 60 + parts[1];
            return seconds;
        }

        async function sendProgressUpdate(isFinished = false) {
            if (!fileId || !userId) return;
            const currentTime = Math.floor(player.currentTime);
            const data = {
                file_id: parseInt(fileId, 10),
                user_id: parseInt(userId, 10),
                position: currentTime,
                is_finished: isFinished
            };
            try {
                await fetch(`${baseApiUrl}/api/update_progress`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
            } catch (error) {
                console.error('Failed to send progress update:', error);
            }
        }

        async function loadAndRenderTimecodes() {
            if (!fileId) return;
            try {
                const response = await fetch(`${baseApiUrl}/api/get_timecodes/${fileId}`);
                const timecodes = await response.json();
                timecodesContainer.innerHTML = '';
                if (Array.isArray(timecodes) && timecodes.length > 0) {
                    timecodes.forEach(tc => {
                        const button = document.createElement('button');
                        button.className = 'timecode-button';
                        button.innerText = `${tc.label} (${tc.time})`;
                        button.onclick = () => {
                            player.currentTime = timeStrToSeconds(tc.time);
                            player.play();
                        };
                        timecodesContainer.appendChild(button);
                    });
                }
            } catch (error) {
                console.error("Failed to load timecodes:", error);
            }
        }

        // --- Главная функция, которая запускает все ---
         async function initializePlayer() {
            try {
                if (!window.MediaSource) {
                    throw new Error('Ваш клиент Telegram не поддерживает Media Source Extensions.');
                }

                const urlParams = new URLSearchParams(window.location.search);
                fileId = urlParams.get('file_id');
                userId = urlParams.get('user_id');
                const fileUrl = urlParams.get('file_url');
                const fileName = urlParams.get('file_name') || 'Аудиозапись';
                const totalDuration = parseInt(urlParams.get('duration') || '0', 10);

                if (!fileUrl || !fileId || !userId) throw new Error("Ключевые параметры не указаны.");
                
                const urlObject = new URL(fileUrl);
                baseApiUrl = `${urlObject.protocol}//${urlObject.host}`;

                titleDiv.innerText = fileName;
                storageKey = `progress_${fileId}`;
                const lastPosition = parseInt(localStorage.getItem(storageKey) || '0', 10);
                timeDisplay.innerText = `${formatTime(lastPosition)} / ${formatTime(totalDuration)}`;
                loaderDiv.innerText = 'Подготовка к воспроизведению...';

                const mediaSource = new MediaSource();
                player.src = URL.createObjectURL(mediaSource);
                
                mediaSource.addEventListener('sourceopen', async () => {
                    loaderDiv.innerText = 'Загрузка аудио...';
                    try {
                        const response = await fetch(fileUrl);
                        if (!response.ok) throw new Error(`Ошибка сети: ${response.statusText}`);

                        let mimeCodec = response.headers.get('Content-Type') || 'audio/mpeg';
                        if (mimeCodec.startsWith('audio/mp4')) {
                            mimeCodec = 'audio/mp4; codecs="mp4a.40.2"';
                        }
                        
                        if (!MediaSource.isTypeSupported(mimeCodec)) {
                            throw new Error(`Формат ${mimeCodec} не поддерживается для стриминга.`);
                        }

                        const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
                        const reader = response.body.getReader();

                        // --- НОВАЯ, БОЛЕЕ ПРОСТАЯ И НАДЕЖНАЯ ЛОГИКА "НАСОСА" ---
                        let isDone = false;
                        while (!isDone) {
                            // Ждем, пока буфер не освободится, если он занят
                            if (sourceBuffer.updating) {
                                await new Promise(resolve => sourceBuffer.addEventListener('updateend', resolve, { once: true }));
                            }
                            
                            // Читаем следующий кусочек
                            const { done, value } = await reader.read();
                            isDone = done;

                            if (value) {
                                // Если есть данные, добавляем их в буфер
                                sourceBuffer.appendBuffer(value);
                            }
                        }
                        
                        // Когда цикл завершился, ждем последнего обновления и закрываем поток
                        if (sourceBuffer.updating) {
                            await new Promise(resolve => sourceBuffer.addEventListener('updateend', resolve, { once: true }));
                        }
                        mediaSource.endOfStream();
                        // --- КОНЕЦ НОВОЙ ЛОГИКИ ---

                    } catch (e) {
                        console.error("Ошибка во время стриминга:", e);
                        loaderDiv.innerText = `Ошибка стриминга: ${e.message}`;
                        if (mediaSource.readyState === "open") {
                            mediaSource.endOfStream('network');
                        }
                    }
                }, { once: true });

                player.addEventListener('canplay', () => {
                    loaderDiv.style.display = 'none';
                    player.controls = true;
                    player.currentTime = lastPosition;
                    player.play();
                }, { once: true });

                loadAndRenderTimecodes();

            } catch (e) {
                loaderDiv.innerText = `Ошибка инициализации: ${e.message}`;
                tg.showAlert(`Критическая ошибка: ${e.message}`);
            }
        }

        // --- Запускаем всю логику ---
        initializePlayer();

        // --- Навешиваем обработчики событий ---
        player.addEventListener('timeupdate', () => {
            const currentTime = Math.floor(player.currentTime);
            localStorage.setItem(storageKey, currentTime);
            const now = Date.now();
            if (now - lastUpdateTime > 5000) {
                sendProgressUpdate();
                lastUpdateTime = now;
            }
        });

        player.addEventListener('ended', () => {
            localStorage.setItem(storageKey, '0');
            sendProgressUpdate(true);
        });
        
        closeButton.addEventListener('click', () => {
            sendProgressUpdate();
            tg.close();
        });
    </script>
</body>
</html>




